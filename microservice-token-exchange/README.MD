Deploy the token exchange container:
```shell
kubectl create -f kube-exchange-env-var.yaml
```
# Token Exchange Use Cases
This readme will describe the various exchange implementations provided.

## Exchange an access token using a JSON-based declarative policy
Token Exchange Policy - JSON
JSON file backed Token-Exchange Policy implementation, which provides logic that decides whether a token-exchange is allowed and what will appear in the generated token.

Settings
This Token-Exchange Policy implementation matches requested resource URI "patterns" to a given "audience", which will appear in the generated token. Alternatively, if the token-exchange-request specifies an "audience" but no resource URIs, then this policy will match that audience. Policy rules are not mutually exclusive, in that multiple policies could match for requested resources/audiences, and the result will be merged together for the generated token.

The example JSON configuration can be overridden either by modifying conf/exchangepolicy_json.json or by setting the optional EXCHANGE_POLICY_JSON_CONFIG_PATH environment variable, which is useful in a container environment (e.g., Docker/Kubernetes).

{
    // (optional) path of JSON config file that overrides this config file, and must only contain simple JSON syntax;
    // property-substitution values and/or inline comments are not allowed
    "configOverridePath" : "&{EXCHANGE_POLICY_JSON_CONFIG_PATH|}",

    "resources" : [
        {
            // patterns to match against the requested resource (either exact-match, or prefix-match up to first *)
            "patterns" : [
                "http://resource1.example.com/*",
                "http://resource1.example.com:80/*",
                "https://resource1.example.com/*",
                "https://resource1.example.com:443/*"
            ],
            // audience associated with this policy
            "audience" : "resource1",
            // scopes provided when resource-patterns and/or audience match
            "scopes" : [
                "resource_read",
                "resource_write"
            ],
            // optional field, to override number of seconds until token expiration, or null
            "expirationSeconds" : 3210,
            // optional array of actor_token subjects allowed to act as actors, or null
            "allowedActors" : [ "client3" ],
            // (optional) additional claims to be copied into generated tokens, or null
            "additionalClaims" : {
                "exampleString" : "value",
                "exampleNumber" : 1,
                "exampleBoolean" : true,
                "exampleObject" : { "key" : "value" },
                "exampleArray" : [ "item" ]
            }
        }
    ]
}
Environment Variables
Name	Description
EXCHANGE_POLICY_JSON_CONFIG_PATH	Absolute filesystem path to JSON configuration for this service (see conf/exchangepolicy_json.json)



## Exchange an access token or id token using OpenAM Policy backend
Token Exchange Policy - OpenAM
Token-Exchange Policy implementation, backed by an OpenAM Policy Set, which takes as input an OpenAM SSO token and request to access one or more resources, and outputs such fields as audience and scope, for the generated token. The generated token can be configured to be the same as those generated by microservice-authn, but it is important to note that the generated token is not and OpenAM token.

The Settings in the next section will map OpenAM Policy attributes to expected/optional values, used in token exchange operations. You can include additional attributes, for a given Policy, which will be automatically copied into the generated token as additional claims. These additional attributes can have values that are any of the JSON types (string, number, boolean, object, array, null), and when multiple policies match a token-exchange-request resources/audience the attributes will be merged together. The logic for merging attributes is to add each unique attribute to an array, and effort is made to prevent duplicates, which in practice may not always work correctly for de-duplicating complex JSON objects.

Support for delegation using the may_act claim in the incoming subject_token is also provided. The actor_token and actor_token_type must be provided with a matching sub claim, and specific configurations in AM must be completed. These are noted below.

Settings
The OpenAM Token-Exchange Policy implementation can be configured by changing settings in the conf/exchangepolicy_openam.json file.

{
    // Credentials for an OpenAM "subject" account with permission to access the OpenAM policy endpoint
    "authSubjectId" : "&{EXCHANGE_OPENAM_AUTH_SUBJECT_ID|exchange_svc}",
    "authSubjectPassword" : "&{EXCHANGE_OPENAM_AUTH_SUBJECT_PASSWORD|exchange_svc}",

    // URL for the OpenAM authentication endpoint, without query parameters
    "authUrl" : "&{EXCHANGE_OPENAM_AUTH_URL|http://localhost:8080/openam/json/realms/root/authenticate}",

    // URL for the OpenAM policy-endpoint, without query parameters
    "policyUrl" : "&{EXCHANGE_OPENAM_POLICY_URL|http://localhost:8080/openam/json/realms/root/policies}",

    // OpenAM Policy-Set ID
    "policySetId" : "&{EXCHANGE_OPENAM_POLICY_SET_ID|resource_policies}",

    // OpenAM policy-endpoint response-attribute field-name containing "audience" values
    "audienceAttribute" : "&{EXCHANGE_OPENAM_POLICY_AUDIENCE_ATTR|aud}",

    // OpenAM policy-endpoint response-attribute field-name containing "scope" values
    "scopeAttribute" : "&{EXCHANGE_OPENAM_POLICY_SCOPE_ATTR|scp}",

    // OpenAM policy-endpoint response-attribute field-name containing the token's "subject" value
    "subjectAttribute" : "&{EXCHANGE_OPENAM_POLICY_SUBJECT_ATTR|uid}",

    // (optional) OpenAM policy-endpoint response-attribute field-name containing "expires-in-seconds" values
    "expiresInSecondsAttribute" : "&{EXCHANGE_OPENAM_POLICY_EXPIRES_IN_SEC_ATTR|}",
                                                                                  
    // Set to "true" to copy additional OpenAM policy-endpoint response-attributes into generated token claims
    "copyAdditionalAttributes" : "&{EXCHANGE_OPENAM_POLICY_COPY_ADDITIONAL_ATTR|true}"
}
Note that the "/realms/root" support in the URLs above is added for the 6.0 release.

Environment Variables
The following are environment variables that can be used to populate fields in conf/exchangepolicy_openam.json,

Name	Description
EXCHANGE_OPENAM_AUTH_SUBJECT_ID	ID/username for an OpenAM "subject" account with permission to access the OpenAM policy endpoint (default: exchange_svc)
EXCHANGE_OPENAM_AUTH_SUBJECT_PASSWORD	Password for an OpenAM "subject" account with permission to access the OpenAM policy endpoint (default: exchange_svc)
EXCHANGE_OPENAM_AUTH_URL	URL for the OpenAM authentication endpoint, without query parameters (default: http://localhost:8080/openam/json/authenticate)
EXCHANGE_OPENAM_POLICY_URL	URL for the OpenAM policy-endpoint, without query parameters (default: http://localhost:8080/openam/json/realms/root/policies)
EXCHANGE_OPENAM_POLICY_SET_ID	OpenAM Policy-Set ID (default: resource_policies)
EXCHANGE_OPENAM_POLICY_AUDIENCE_ATTR	OpenAM policy-endpoint response-attribute field-name containing "audience" values (default: aud)
EXCHANGE_OPENAM_POLICY_SCOPE_ATTR	OpenAM policy-endpoint response-attribute field-name containing "scope" values (default: scp)
EXCHANGE_OPENAM_POLICY_SUBJECT_ATTR	OpenAM policy-endpoint response-attribute field-name containing the token's "subject" value (default: uid)
EXCHANGE_OPENAM_POLICY_ALLOWED_ACTORS_ATTR	OpenAM policy-endpoint response-attribute field-name containing a list of allowed actors (default: allowedActors)
EXCHANGE_OPENAM_POLICY_EXPIRES_IN_SEC_ATTR	(Optional) OpenAM policy-endpoint response-attribute field-name containing "expires-in-seconds" values
EXCHANGE_OPENAM_POLICY_COPY_ADDITIONAL_ATTR	Set to "true" to copy additional OpenAM policy-endpoint response-attributes into generated token claims, or "false" to disable this feature (default: "true")
Configure OpenAM
In order to use the OpenAM Token Exchange Policy API implementation, some minimal configuration steps must be followed for OpenAM itself.

Copy the OpenAM WAR file into the Tomcat Application Server's /webapps directory, and rename file to openam.war
Execute catalina start from the command line
Create an OpenAM group with the "REST calls for policy evaluation" privilege
Realms > Subjects > Group (tab) > New > ID: policy-eval-group > OK
Privileges (tab) > click on the group > check: "REST calls for policy evaluation" > Save
Create a user that is part of that group
Subjects (tab) > New > ID: exchange_svc, password: exchange_svc > OK
Subjects (tab) > click on user > Group (tab) > Add: policy-eval-group > Save
Create another user, to use in the examples for token-exchange
Subjects (tab) > New > ID: example_user, password: example_user > OK
Create a Policy Set
Realms > Authorization > Policy Sets > New Policy Set > ID: resource_policies, Name: "Resource Policies", Resource Types: URL > Create
Add Policy > Name: "Example Resources", Resource Type: URL, Resource Pattern: *://resource1.example.com:*/*> Add > Create
Subjects (tab) > click pencil-icon > choose "Authenticated Users" > click checkmark-icon > Save Changes
Response Attributes (tab)
Subject Attributes: uid
Static Attributes (name/value): aud / resource1 > click plus-icon
Static Attributes (name/value): scp / resource_read > click plus-icon
Static Attributes (name/value) scp / resource_write > click plus-icon
(optional) Static Attributes (name/value): expiresIn / 3600 > click plus-icon
Save Changes
(optional) This step is for Delegation only Note: The policy specifics do not change from those defined above.
Create a custom OIDC Claims script to add the may_act claim based on any condition such as group membership a) A very simple example that checks for group membership before assigning the delegate is shown here:
''' import org.forgerock.oauth2.core.UserInfoClaims import com.sun.identity.idm.IdType

def isAdmin = identity.getMemberships(IdType.GROUP) .inject(false) { found, group -> found || group.getName() == "policyEval"

}

def mayact = [:] if (isAdmin) { mayact.put("sub","user.2") }

return new UserInfoClaims([ "may_act": mayact ], ["openid":["may_act"]]) '''

2. Attach this custom OIDC claims script to the OAuth2 Provider
3. Create a custom policy condition script to extract the sub claim from the JWT
    a) An example is here: https://github.com/javedmshah/token-exchange-microservice
4. Attach the policy condition script to the Environment of the OAuth2 policy
NOTE: A token-exchange request can specify one or more resource and/or audience fields, but OpenAM considers any/all resources/audiences in the request to be a "resource" of some "resource type". By default the URL resource-type is supported in OpenAM, so you may need to create additional resource-types within OpenAM to support a non-URL audience values.

CURL Examples
The following examples assume that the jq tool is installed. Ports may need to be changed in the CURL commands.

Generate an OpenAM token and save it to a file. The OpenAM example_user account is used in the example, but any OpenAM SSO account could be used.

export OPENAM_USERNAME=example_user
export OPENAM_PASSWORD=example_user

curl -s --request POST \
  --header "X-OpenAM-Username: $OPENAM_USERNAME" \
  --header "X-OpenAM-Password: $OPENAM_PASSWORD" \
  --header "Content-Type: application/json" \
  "http://localhost:8080/openam/json/authenticate" > openam_sso_token.json
Verify that both microservice-authn and microservice-token-exchange are using the same JSON Web Key for token signing/validation, by setting the following environment variables before starting the services,

- microservice-authn
export TOKEN_SIGNATURE_JWK_BASE64=ewogICAgImtpZCIgOiAibXlfaG1hY19rZXkiLAogICAgImt0eSIgOiAiT0NUIiwKICAgICJhbGciIDogIkhTMjU2IiwKICAgICJrIiA6ICJGZEZZRnpFUndDMnVDQkI0NnBaUWk0R0c4NUx1alI4b2J0LUtXUkJJQ1ZRIgp9Cg==

- microservice-token-exchange
export ISSUER_JWK_JSON_JWK_BASE64=$TOKEN_SIGNATURE_JWK_BASE64
Next, generate a token with microservice-authn, and the example "client3" account that has "exchange" scope (see "requiredBearerScope" setting in conf/service.json), to use as a Authorization Bearer token,

- microservice-authn
curl -k -u client3:client3 -X POST \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "grant_type=client_credentials" \
    -d "scope=exchange" \
    "http://localhost:8080/service/access_token" > bearer_tok.json
Use the Bearer token to authenticate with microservice-token-exchange's endpoint, and pass in the OpenAM token generated previously,

export EX_BEARER_TOKEN=$(cat bearer_tok.json | jq -r .access_token)
export EX_SUBJECT_TOKEN=$(cat openam_sso_token.json | jq -r .tokenId)

- specifies two resources
curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "resource=http://resource1.example.com/thing/99" \
    -d "resource=http://resource1.example.com/thing/100" \
    -d "subject_token=$EX_SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -H "Authorization: Bearer $EX_BEARER_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://localhost:8080/service/tokensts" | jq
The output should look something like,

{
  "access_token": "eyJ0eXAiOiJKV1QiLCJ6aXAiOi...",
  "issued_token_type": "urn:ietf:params:oauth:token-type:access_token",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "resource_write resource_read"
}
And if we were to introspect the token, we might see,

{
   "sub":"example_user",
   "aud":"resource1",
   "scp":[
      "resource_write",
      "resource_read"
   ],
   "iss":"https://example.com",
   "exp":1495223381,
   "iat":1495219781
}
Delegation Support

The subject_token includes may_act as shown:

{
    "at_hash": "EpGvTWe0WBJGJEdgUF2-2w",
    "sub": "Alice",
    "auditTrackingId": "079fda18-c96f-4c78-90f2-fc9be0545b32-204563",
    "iss": "http://localhost:8080/openam/oauth2",
    "tokenName": "id_token",
    "aud": "oidccient",
    "azp": "oidccient",
    "auth_time": 1523084106,
    "realm": "/",
    "may_act": {
        "sub": "Bob"
    },
    "exp": 1523087706,
    "tokenType": "JWTToken",
    "iat": 1523084106
}
The actor_token is:

{
    "at_hash": "vMH7NUGN9cCADdI_Dp5bSg",
    "sub": "Bob",
    "auditTrackingId": "079fda18-c96f-4c78-90f2-fc9be0545b32-204537",
    "iss": "http://localhost:8080/openam/oauth2",
    "tokenName": "id_token",
    "aud": "oidcclient",
    "azp": "oidcclient",
    "auth_time": 1523084104,
    "realm": "/",
    "exp": 1523087704,
    "tokenType": "JWTToken",
    "iat": 1523084104
}
An example of using delegation is as follows: curl -k
-d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" 
-d "resource=http://images.example.com:/" 
-d "subject_token=$EX_SUBJECT_TOKEN" 
-d "subject_token_type=urn:ietf:params:oauth:token-type:id_token" 
-d "actor_token=$EX_ACTOR_TOKEN" 
-d "actor_token_type=urn:ietf:params:oauth:token-type:id_token" 
-H "Authorization: Bearer $EX_BEARER_TOKEN" 
-H "Content-Type: application/x-www-form-urlencoded" 
-X POST "http://localhost:38080/service/tokensts" | jq

If the AM policy check is successful, the returned JWT access_ttoken would be:

{
    "sub": "user.0",
    "aud": "example.com",
    "scp": [
        "read",
        "write"
    ],
    "act": {
        "sub": "user.1"
    },
    "iss": "https://fr.tokenexchange.example.com",
    "exp": 1523382895,
    "iat": 1523379295
}

## JWT
Token Exchange Policy - JWT
Token-Exchange Policy implementation, which performs a simple token exchange, for a JWT, given any token that can be introspected by the configured Token Introspection service (e.g., microservice-token-validation project).

Implementation and usage notes:

The Bearer token, used to authenticate, must have scope claims for both token exchange and token introspection
Exchange request must have requested_token_type=urn:ietf:params:oauth:token-type:jwt
The audience and resource parameters, in the exchange request, are currently ignored and not applicable
If the given subject_token can be introspected, then a JWT is returned containing the claims of the subject_token
When the subject_token does not contain the sub, aud, and scope or scp claims, they are given a N_A value
If the exchange request specifies one or more optional scope parameters, those scopes must exist in the subject_token
The optional exchange request actor_token must be a JWT signed by one of the keys in the configured Issuer JSON Web Key Store
If an actor_token is specified, the optional may_act claim will be respected if found in the subject_token
Settings
The conf/resources/exchangepolicy_jwt.json configuration file requires an "introspectUrl", which points to a microservice-token-validation endpoint, and the "issuerJsonWebKeyStore" field, which is currently only used to validate the optional actor_token's signature.

{
    // URL to Token Introspection service
    "introspectUrl" : "&{EXCHANGE_JWT_INTROSPECT_URL|http://localhost:8080/service/introspect}",

    // Comma-separated names of Issuer JSON Web Key Store implementations, which maps OAuth token issuers to JSON Web Keys
    // NOTE: this is currently only used to validate the optional actor_token
    "issuerJsonWebKeyStore" : "&{ISSUER_JWK_STORE|json}"
}
Environment Variables
Name	Description
EXCHANGE_JWT_INTROSPECT_URL	URL to Token Introspection service (see conf/exchangepolicy_jwt.json)
ISSUER_JWK_STORE	Comma-separated, priority ordered list of Issuer JSON Web Key Store implementations to use, which is json by default (See conf/service.json).
Example Usage
The following environment variables are useful in configuring the Token Exchange Microservice to utilize the JWT Token Exchange policy:

- These environment variables are provided by the YAML file (no need to set explicitly)
export TOKEN_SIGNATURE_JWK_BASE64=ewogICAgImtpZCIgOiAibXlfaG1hY19rZXkiLAogICAgImt0eSIgOiAiT0NUIiwKICAgICJhbGciIDogIkhTMjU2IiwKICAgICJrIiA6ICJGZEZZRnpFUndDMnVDQkI0NnBaUWk0R0c4NUx1alI4b2J0LUtXUkJJQ1ZRIgp9Cg==
export ISSUER_JWK_JSON_JWK_BASE64=$TOKEN_SIGNATURE_JWK_BASE64

export EXCHANGE_JWT_INTROSPECT_URL="http://192.168.99.100:30103/service/introspect"

TOKEN_EXCHANGE_POLICIES="jwt,json" token-exchange-microservice/bin/startup.sh jpda
Use microservice-authn to generate bearer and subject tokens:

- the example client3 account has both exchange and introspect scopes
export AUTH_TOKEN=$(curl -k -u client3:client3 -X POST \
  -d "grant_type=client_credentials" \
  -d "scope=exchange%20introspect" \
  "http://192.168.99.100:30101/service/access_token" \
  | jq -r .access_token)

export SUBJECT_TOKEN=$(curl -k -u client2:client2 -X POST \
  -d "grant_type=client_credentials" \
  "http://192.168.99.100:30101/service/access_token" \
  | jq -r .access_token)
Exchange subject_token for a JWT:

curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=$SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "requested_token_type=urn:ietf:params:oauth:token-type:jwt" \
    -H "Authorization: Bearer $AUTH_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://localhost:8080/service/tokensts" | jq
Exchange subject_token, with optional actor_token specified, for a JWT:

curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=$SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "actor_token=$AUTH_TOKEN" \
    -d "actor_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "requested_token_type=urn:ietf:params:oauth:token-type:jwt" \
    -H "Authorization: Bearer $AUTH_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://localhost:8080/service/tokensts" | jq
    
## Token exchange using Open Policy Agent (opa)
Token Exchange Policy - Open Policy Agent (OPA)
Open Policy Agent (OPA) file backed Token-Exchange Policy implementation, which provides logic that decides whether a token-exchange is allowed and what will appear in the generated token.

Settings
This Token-Exchange Policy implementation matches requested resource "patterns" to a given "audience", which will appear in the generated token. Alternatively, if the token-exchange-request specifies an "audience" but no resource URIs, then this policy will match that audience. Policy rules are not mutually exclusive, in that multiple policies could match for requested resources/audiences, and the result will be merged together for the generated token.

The JSON configuration file for this module is located at conf/exchangepolicy_opa.json and is shown below:

{
    // Comma-separated names of Issuer JSON Web Key Store implementations, which maps OAuth token issuers to JSON Web Keys
    "issuerJsonWebKeyStore" : "&{ISSUER_JWK_STORE|json}",

    // Open Policy Agent URL for the token exchange policy
    "url":"&{EXCHANGE_POLICY_OPA_URL|http://localhost:8181/v0/data/forgerock/exchange/match}"
}
Environment Variables
Name	Description
ISSUER_JWK_STORE	Comma-separated, priority ordered list of Issuer JSON Web Key Store implementations to use, which is json by default (See conf/service.json).
EXCHANGE_POLICY_OPA_URL	Open Policy Agent URL for the token exchange policy, which usually runs as a local service.
Open Policy Agent
The Open Source Open Policy Agent project possess many powerful features, such as the Rego scripting language, based on Datalog, and HTTP capabilities which make it possible to manage policies as part of your overall microservice infrastructure. This Token Exchange module is opinionated about the JSON payload that is sent to OPA and the JSON response from OPA, but there is great flexibility in how policy rules are evaluated inside OPA itself.

An example HTTP request JSON payload, sent to OPA for evaluation, is:

{
  "resources" : [
    "http://resource1.example.com/endpoint"
  ],
  "audiences" : [
    "resource2"
  ]
}
This example requests a resource name, which is associated with "resource1", and also explicitly requests access to "resource2".

exchangePolicy.json
Example exchangePolicy.json file, which defines the policy rule data inside OPA:

{
    "resources" : [
        {
            "patterns" : [
                "^https?://resource1.example.com/.*",
                "^http://resource1.example.com:80/.*",
                "^https://resource1.example.com:443/.*"
            ],
            "audience" : "resource1",
            "scopes" : [
                "resource_read",
                "resource_write"
            ],
            "expirationSeconds" : 3210,
            "allowedActors" : [ "client3" ],
            "additionalClaims" : {
                "exampleString" : "value",
                "exampleNumber" : 1,
                "exampleBoolean" : true,
                "exampleObject" : { "key" : "value" },
                "exampleArray" : [ "item" ]
            }
        },
        {
            "patterns" : [
                "^http://resource2.example.com/.*",
                "^http://resource2.example.com:80/.*"
            ],
            "audience" : "resource2",
            "scopes" : [
                "resource_read"
            ]
        }
    ]
}
If you are familiar with the JSON Token Exchange Policy module, which is the default exchange policy implementation, you will notice that the JSON schema above is extremely similar. One notable difference is that the "patterns" in this case are full fledged regular expressions, instead of the simpler pattern language assumed by the other module. Since OPA was written in the Go programming language, we assume that the regular expressions are those valid in Go (see re2 syntax).

Although we show URI patterns above, resources are not restricted to be URIs. If at least one resource pattern matches, or the audience matches, then then rule matches. Remember that a token exchange request may consist of requested resources, audiences, or both. This module considers it an error if neither resources or audiences are in the token exchange request.

These JSON definitions specify how resources and/or audiences are related within exchange policies, and also follow the JSON schema expected by this exchange policy module in JSON responses from OPA. The following fields are expected to be returned by OPA:

audience (required) : audience on the newly issued token
scopes (optional) : scopes placed on the newly issued token
expirationSeconds (optional) : must be 0 or higher, or uses the default in conf/services.json
allowedActors (optional) : subjects of callers (bearer token) that can be exchange actors (all allowed by default)
additionalClaims (optional) : which are ad-hoc claims added to the token and cannot override mandatory OAuth 2 claims
exchangePolicy.rego
Example exchangePolicy.rego file, which defines the logic of the exchange policy:

package forgerock.exchange

import data.resources

/*
* RUN IN SERVER MODE:
*
* ./opa run --server  exchangePolicy.json exchangePolicy.rego
*/

lookupByResourcePattern = output {
  z = [r | re_match(resources[i].patterns[_], input.resources[_]); resources[i] = r]
  // convert array into set
  output = {x | x = z[_]}
}

lookupByAudience = output {
  z = [r | resources[i].audience = input.audiences[_]; resources[i] = r]
  // convert array into set
  output = {x | x = z[_]}
}

- curl -H "Content-Type: application/json" --request POST --data-binary "@exchangeInput.json" http://localhost:8181/v0/data/forgerock/exchange/match
match = output {
  a = lookupByAudience
  b = lookupByResourcePattern
  output = a | b
}
This example Rego file supports matching of items inside the "resources" array, shown above in the example exchangePolicy.json file, with requested audiences and/or resources. The important point is that the response from the match rule returns an array of matching items from the "resources" array. Other than the restriction on the JSON request and JSON response formats, you can perform whatever complex evaluations are necessary in your own Rego files.

Run OPA Server
Run the OPA server locally on the default port (8181):

./opa run --server  exchangePolicy.json exchangePolicy.rego
HTTP Request from Token Exchange Microservice
Example HTTP request payload from the Token Exchange Microservice, which you could save to exchangeInput.json:

{
  "resources" : [
    "http://resource1.example.com/endpoint"
  ],
  "audiences" : [
    "resource2"
  ]
}
Issue the example HTTP request via:

curl -H "Content-Type: application/json" \
    --request POST \
    --data-binary "@exchangeInput.json" \
    http://localhost:8181/v0/data/forgerock/exchange/match
