Deploy the token exchange container:
```shell
kubectl create -f kube-exchange-env-var.yaml
```
# Token Exchange Use Cases
This readme will describe the various exchange implementations provided.

## Exchange an access token using a JSON-based declarative policy
Token Exchange Policy - JSON
JSON file backed Token-Exchange Policy implementation, which provides logic that decides whether a token-exchange is allowed and what will appear in the generated token.

Settings
This Token-Exchange Policy implementation matches requested resource URI "patterns" to a given "audience", which will appear in the generated token. Alternatively, if the token-exchange-request specifies an "audience" but no resource URIs, then this policy will match that audience. Policy rules are not mutually exclusive, in that multiple policies could match for requested resources/audiences, and the result will be merged together for the generated token.

A sample JSON policy looks like:

``{
    
    "resources" : [
        {
            // patterns to match against the requested resource (either exact-match, or prefix-match up to first *)
            "patterns" : [
                "http://resource1.example.com/*",
                "http://resource1.example.com:80/*",
                "https://resource1.example.com/*",
                "https://resource1.example.com:443/*"
            ],
            // audience associated with this policy
            "audience" : "resource1",
            // scopes provided when resource-patterns and/or audience match
            "scopes" : [
                "resource_read",
                "resource_write"
            ],
            // optional field, to override number of seconds until token expiration, or null
            "expirationSeconds" : 3210,
            // optional array of actor_token subjects allowed to act as actors, or null
            "allowedActors" : [ "client3" ],
            // (optional) additional claims to be copied into generated tokens, or null
            "additionalClaims" : {
                "exampleString" : "value",
                "exampleNumber" : 1,
                "exampleBoolean" : true,
                "exampleObject" : { "key" : "value" },
                "exampleArray" : [ "item" ]
            }
        }
    ]
}``

## Exchange an access token or id token using OpenAM Policy backend
Token Exchange Policy - OpenAM
Token-Exchange Policy implementation, backed by an OpenAM Policy Set, which takes as input an OpenAM SSO token and request to access one or more resources, and outputs such fields as audience and scope, for the generated token. The generated token can be configured to be the same as those generated by microservice-authn, but it is important to note that the generated token is not and OpenAM token.

The Settings in the next section will map OpenAM Policy attributes to expected/optional values, used in token exchange operations. You can include additional attributes, for a given Policy, which will be automatically copied into the generated token as additional claims. These additional attributes can have values that are any of the JSON types (string, number, boolean, object, array, null), and when multiple policies match a token-exchange-request resources/audience the attributes will be merged together. The logic for merging attributes is to add each unique attribute to an array, and effort is made to prevent duplicates, which in practice may not always work correctly for de-duplicating complex JSON objects.

Support for delegation using the may_act claim in the incoming subject_token is also provided. The actor_token and actor_token_type must be provided with a matching sub claim, and specific configurations in AM must be completed. These are noted below.

Settings
The environment variables are included in the YAML file.

Note that the "/realms/root" support in the URLs above is added for the 6.0 release.

## Configure OpenAM
In order to use the OpenAM Token Exchange Policy API implementation, some minimal configuration steps must be followed for OpenAM itself.
The attached amster configuration already includes the configurations needed.

Copy the OpenAM WAR file into the Tomcat Application Server's /webapps directory, and rename file to openam.war
Execute catalina start from the command line
Create an OpenAM group with the "REST calls for policy evaluation" privilege
Realms > Subjects > Group (tab) > New > ID: policy-eval-group > OK
Privileges (tab) > click on the group > check: "REST calls for policy evaluation" > Save
Create a user that is part of that group
Subjects (tab) > New > ID: exchange_svc, password: exchange_svc > OK
Subjects (tab) > click on user > Group (tab) > Add: policy-eval-group > Save
Create another user, to use in the examples for token-exchange
Subjects (tab) > New > ID: example_user, password: example_user > OK
Create a Policy Set
Realms > Authorization > Policy Sets > New Policy Set > ID: resource_policies, Name: "Resource Policies", Resource Types: URL > Create
Add Policy > Name: "Example Resources", Resource Type: URL, Resource Pattern: *://resource1.example.com:*/*> Add > Create
Subjects (tab) > click pencil-icon > choose "Authenticated Users" > click checkmark-icon > Save Changes
Response Attributes (tab)
Subject Attributes: uid
Static Attributes (name/value): aud / resource1 > click plus-icon
Static Attributes (name/value): scp / resource_read > click plus-icon
Static Attributes (name/value) scp / resource_write > click plus-icon
(optional) Static Attributes (name/value): expiresIn / 3600 > click plus-icon
Save Changes
(optional) This step is for Delegation only Note: The policy specifics do not change from those defined above.
Create a custom OIDC Claims script to add the may_act claim based on any condition such as group membership a) A very simple example that checks for group membership before assigning the delegate is shown here:
''' import org.forgerock.oauth2.core.UserInfoClaims import com.sun.identity.idm.IdType

def isAdmin = identity.getMemberships(IdType.GROUP) .inject(false) { found, group -> found || group.getName() == "policyEval"

}

def mayact = [:] if (isAdmin) { mayact.put("sub","user.2") }

return new UserInfoClaims([ "may_act": mayact ], ["openid":["may_act"]]) '''

2. Attach this custom OIDC claims script to the OAuth2 Provider
3. Create a custom policy condition script to extract the sub claim from the JWT
    a) An example is here: https://github.com/javedmshah/token-exchange-microservice
4. Attach the policy condition script to the Environment of the OAuth2 policy
NOTE: A token-exchange request can specify one or more resource and/or audience fields, but OpenAM considers any/all resources/audiences in the request to be a "resource" of some "resource type". By default the URL resource-type is supported in OpenAM, so you may need to create additional resource-types within OpenAM to support a non-URL audience values.

CURL Examples
The attached POSTMAN collection includes all examples.

Generate the AM and BEARER tokens with POSTMAN, and the example "client3" account that has "exchange" scope to use as a Authorization Bearer token.

Use the Bearer token to authenticate with microservice-token-exchange's endpoint, and pass in the OpenAM token generated previously,
POSTMAN includes a few examples of this but you could modify the collection as needed.

- specifies two resources
``
curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "resource=http://resource1.example.com/thing/99" \
    -d "resource=http://resource1.example.com/thing/100" \
    -d "subject_token=$EX_SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -H "Authorization: Bearer $EX_BEARER_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://19.168.99.100:30104/service/tokensts" | jq
``    
The output should look something like,
``
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJ6aXAiOi...",
  "issued_token_type": "urn:ietf:params:oauth:token-type:access_token",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "resource_write resource_read"
}``
And if we were to introspect the token, we might see,
``
{
   "sub":"example_user",
   "aud":"resource1",
   "scp":[
      "resource_write",
      "resource_read"
   ],
   "iss":"https://example.com",
   "exp":1495223381,
   "iat":1495219781
}``
Delegation Support

The subject_token includes may_act as shown:
``
{
    "at_hash": "EpGvTWe0WBJGJEdgUF2-2w",
    "sub": "Alice",
    "auditTrackingId": "079fda18-c96f-4c78-90f2-fc9be0545b32-204563",
    "iss": "http://localhost:8080/openam/oauth2",
    "tokenName": "id_token",
    "aud": "oidccient",
    "azp": "oidccient",
    "auth_time": 1523084106,
    "realm": "/",
    "may_act": {
        "sub": "Bob"
    },
    "exp": 1523087706,
    "tokenType": "JWTToken",
    "iat": 1523084106
}``
The actor_token is:
``
{
    "at_hash": "vMH7NUGN9cCADdI_Dp5bSg",
    "sub": "Bob",
    "auditTrackingId": "079fda18-c96f-4c78-90f2-fc9be0545b32-204537",
    "iss": "http://localhost:8080/openam/oauth2",
    "tokenName": "id_token",
    "aud": "oidcclient",
    "azp": "oidcclient",
    "auth_time": 1523084104,
    "realm": "/",
    "exp": 1523087704,
    "tokenType": "JWTToken",
    "iat": 1523084104
}``
An example of using delegation is as follows: curl -k
-d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" 
-d "resource=http://images.example.com:/" 
-d "subject_token=$EX_SUBJECT_TOKEN" 
-d "subject_token_type=urn:ietf:params:oauth:token-type:id_token" 
-d "actor_token=$EX_ACTOR_TOKEN" 
-d "actor_token_type=urn:ietf:params:oauth:token-type:id_token" 
-H "Authorization: Bearer $EX_BEARER_TOKEN" 
-H "Content-Type: application/x-www-form-urlencoded" 
-X POST "http://localhost:38080/service/tokensts" | jq

If the AM policy check is successful, the returned JWT access_ttoken would be:
``
{
    "sub": "user.0",
    "aud": "example.com",
    "scp": [
        "read",
        "write"
    ],
    "act": {
        "sub": "user.1"
    },
    "iss": "https://fr.tokenexchange.example.com",
    "exp": 1523382895,
    "iat": 1523379295
}
``
## JWT
Token Exchange Policy - JWT
Token-Exchange Policy implementation, which performs a simple token exchange, for a JWT, given any token that can be introspected by the configured Token Introspection service (e.g., microservice-token-validation project).

Implementation and usage notes:

The Bearer token, used to authenticate, must have scope claims for both token exchange and token introspection
Exchange request must have `requested_token_type`=urn:ietf:params:oauth:token-type:jwt
The audience and resource parameters, in the exchange request, are currently ignored and not applicable
If the given `subject_token` can be introspected, then a JWT is returned containing the claims of the `subject_token`
When the `subject_token` does not contain the sub, aud, and scope or scp claims, they are given a N_A value
If the exchange request specifies one or more optional scope parameters, those scopes must exist in the `subject_token`
The optional exchange request `actor_token` must be a JWT signed by one of the keys in the configured Issuer JSON Web Key Store
If an `actor_token` is specified, the optional may_act claim will be respected if found in the `subject_token`

Settings
The conf/resources/exchangepolicy_jwt.json configuration file requires an "introspectUrl", which points to a microservice-token-validation endpoint, and the "issuerJsonWebKeyStore" field, which is currently only used to validate the optional actor_token's signature.
``
{
    // URL to Token Introspection service
    "introspectUrl" : "&{EXCHANGE_JWT_INTROSPECT_URL|http://19.168.99.100:30103/service/introspect}",

    // Comma-separated names of Issuer JSON Web Key Store implementations, which maps OAuth token issuers to JSON Web Keys
    // NOTE: this is currently only used to validate the optional actor_token
    "issuerJsonWebKeyStore" : "&{ISSUER_JWK_STORE|json}"
}
``
Use POSTMAN to generate bearer and subject tokens:

Exchange subject_token for a JWT:
``
curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=$SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "requested_token_type=urn:ietf:params:oauth:token-type:jwt" \
    -H "Authorization: Bearer $AUTH_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://localhost:8080/service/tokensts" | jq
``
Exchange subject_token, with optional actor_token specified, for a JWT:
``
curl -k \
    -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=$SUBJECT_TOKEN" \
    -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "actor_token=$AUTH_TOKEN" \
    -d "actor_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "requested_token_type=urn:ietf:params:oauth:token-type:jwt" \
    -H "Authorization: Bearer $AUTH_TOKEN" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -X POST "http://localhost:8080/service/tokensts" | jq
``   
## Token exchange using Open Policy Agent (opa)
Token Exchange Policy - Open Policy Agent (OPA)
Open Policy Agent (OPA) file backed Token-Exchange Policy implementation, which provides logic that decides whether a token-exchange is allowed and what will appear in the generated token.

Settings
This Token-Exchange Policy implementation matches requested resource "patterns" to a given "audience", which will appear in the generated token. Alternatively, if the token-exchange-request specifies an "audience" but no resource URIs, then this policy will match that audience. Policy rules are not mutually exclusive, in that multiple policies could match for requested resources/audiences, and the result will be merged together for the generated token.

The JSON configuration file for this module is located at conf/exchangepolicy_opa.json

An example HTTP request JSON payload, sent to OPA for evaluation, is:
``
{
  "resources" : [
    "http://resource1.example.com/endpoint"
  ],
  "audiences" : [
    "resource2"
  ]
}``
This example requests a resource name, which is associated with "resource1", and also explicitly requests access to "resource2".

exchangePolicy.json
Example exchangePolicy.json file, which defines the policy rule data inside OPA:
``
{
    "resources" : [
        {
            "patterns" : [
                "^https?://resource1.example.com/.*",
                "^http://resource1.example.com:80/.*",
                "^https://resource1.example.com:443/.*"
            ],
            "audience" : "resource1",
            "scopes" : [
                "resource_read",
                "resource_write"
            ],
            "expirationSeconds" : 3210,
            "allowedActors" : [ "client3" ],
            "additionalClaims" : {
                "exampleString" : "value",
                "exampleNumber" : 1,
                "exampleBoolean" : true,
                "exampleObject" : { "key" : "value" },
                "exampleArray" : [ "item" ]
            }
        },
        {
            "patterns" : [
                "^http://resource2.example.com/.*",
                "^http://resource2.example.com:80/.*"
            ],
            "audience" : "resource2",
            "scopes" : [
                "resource_read"
            ]
        }
    ]
}``
If you are familiar with the JSON Token Exchange Policy module, which is the default exchange policy implementation, you will notice that the JSON schema above is extremely similar. One notable difference is that the "patterns" in this case are full fledged regular expressions, instead of the simpler pattern language assumed by the other module. Since OPA was written in the Go programming language, we assume that the regular expressions are those valid in Go (see re2 syntax).

Although we show URI patterns above, resources are not restricted to be URIs. If at least one resource pattern matches, or the audience matches, then then rule matches. Remember that a token exchange request may consist of requested resources, audiences, or both. This module considers it an error if neither resources or audiences are in the token exchange request.

These JSON definitions specify how resources and/or audiences are related within exchange policies, and also follow the JSON schema expected by this exchange policy module in JSON responses from OPA. The following fields are expected to be returned by OPA:

audience (required) : audience on the newly issued token
scopes (optional) : scopes placed on the newly issued token
expirationSeconds (optional) : must be 0 or higher, or uses the default in conf/services.json
allowedActors (optional) : subjects of callers (bearer token) that can be exchange actors (all allowed by default)
additionalClaims (optional) : which are ad-hoc claims added to the token and cannot override mandatory OAuth 2 claims
exchangePolicy.rego
Example exchangePolicy.rego file, which defines the logic of the exchange policy:
``
package forgerock.exchange
import data.resources

// ./opa run --server  exchangePolicy.json exchangePolicy.rego


lookupByResourcePattern = output {
  z = [r | re_match(resources[i].patterns[_], input.resources[_]); resources[i] = r]
  // convert array into set
  output = {x | x = z[_]}
}

lookupByAudience = output {
  z = [r | resources[i].audience = input.audiences[_]; resources[i] = r]
  // convert array into set
  output = {x | x = z[_]}
}
``
`` curl -H "Content-Type: application/json" --request POST --data-binary "@exchangeInput.json" http://localhost:8181/v0/data/forgerock/exchange/match
match = output {
  a = lookupByAudience
  b = lookupByResourcePattern
  output = a | b
}
``
This example Rego file supports matching of items inside the "resources" array, shown above in the example exchangePolicy.json file, with requested audiences and/or resources. The important point is that the response from the match rule returns an array of matching items from the "resources" array. Other than the restriction on the JSON request and JSON response formats, you can perform whatever complex evaluations are necessary in your own Rego files.

Run OPA Server
Run the OPA server locally on the default port (8181):

./opa run --server  exchangePolicy.json exchangePolicy.rego
HTTP Request from Token Exchange Microservice
Example HTTP request payload from the Token Exchange Microservice, which you could save to exchangeInput.json:
``
{
  "resources" : [
    "http://resource1.example.com/endpoint"
  ],
  "audiences" : [
    "resource2"
  ]
}
``
Issue the example HTTP request via:
``
curl -H "Content-Type: application/json" \
    --request POST \
    --data-binary "@exchangeInput.json" \
    http://localhost:8181/v0/data/forgerock/exchange/match
``
